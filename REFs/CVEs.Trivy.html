<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>CVEs.Trivy</title>
    <link rel="icon" href="https://sempernow.github.io/refpages/sa/favicon.png">
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/normalize.css">
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/main.css">
    <!--
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/dev.css">
    -->
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/hljs.github.min.css">
    <style>

    </style>
    <script src="https://sempernow.github.io/refpages/sa/js/hl.min.js"></script>
    <script>hljs.highlightAll()</script>
</head>
<body>
    <main>
        <h1>Trivy : CVEs Scanner | <a href="https://aquasecurity.github.io/trivy/v0.52/docs/">Docs</a> | <a href="https://hub.docker.com/r/aquasec/trivy" title="hub.docker.com">Trivy image</a></h1>

<blockquote>
<p>Trivy scans <def title="'Open Containers Initiative' compliant">OCI-container</def> images, OS folders, Kubernetes clusters, Git repos, virtual machines, and more. And can create <def title="Software Bill of Materials">SBOM</def> and <def title="Critical Vulnerabilities and Exploits">CVE-vulnerabilities</def> audits of them.</p>
</blockquote>

<h2>Install</h2>

<pre><code class="language-bash">mkdir -p trivy
cd trivy

# Download/Extract the binary
ver='0.49.1'
tarball=&quot;trivy_${ver}_Linux-64bit.tar.gz&quot;
url=https://github.com/aquasecurity/trivy/releases/download/v${ver}/$tarball
curl -LO $url &amp;&amp; tar -xvaf $tarball

# Install it
sudo cp trivy /usr/local/bin/
</code></pre>

<ul>
<li><a href="https://github.com/aquasecurity/trivy/releases"><strong>Releases</strong></a></li>
</ul>

<h2>Useage</h2>

<h3>TL;DR : Scan OCI image for CVEs</h3>

<pre><code class="language-bash"># Generate SBOM of OCI image
image=openeuler/openeuler:24.03-lts-sp2
trivy image --scanners vuln --format spdx-json -o sbom.sdx.json $image
# or
trivy image --scanners vuln --format cyclonedx -o sbom.cdx.json $image 

# Scan/Audit SBOM file for CVEs of declared severities
sbom=sbom.cdx
trivy sbom --severity CRITICAL,HIGH --format json -o $sbom.audit.json $sbom.json

</code></pre>

<h3>List of Commands</h3>

<pre><code class="language-bash"># Update Trivy's CVEs database
trivy image --download-db-only 

# Remove cached databases
trivy image --reset

# Scan container (ctnr) image and log results
trivy image -o log $image

# Scan ctnr image for CVEs, create its SPDX-compliant SBOM, out to JSON
sbom=sbom.spdx
trivy image --scanners vuln --format spdx-json -o $sbom.json $image
# Scan/Audit SBOM file for vulnerabilities (CVEs) of declared severities
trivy sbom --severity CRITICAL,HIGH --format json -o $sbom.audit.json $sbom.json

# Scan K8s cluster (experimental)
trivy k8s --report summary $cluster_name

# Scan host filesystem (FS)
trivy fs --scanners vuln,secret,misconfig $target_path

# Scan a binary file on host filesystem (FS)
trivy fs --scanners vuln,secret,misconfig $(which $bin)

# Scan a remote repo
trivy repo https://github.com/aquasecurity/trivy-ci-test

# Scan a virtual machine image
trivy vm --scanners vuln $adisk.vmdk

# Scan AWS machine image
trivy vm ami:$id

# Scan AWS EBS snapshot
trivy vm ebs:$id

</code></pre>

<h3>Trivy Format Options</h3>

<p>Regarding SBOMs and CVE audits of OCI-compliant (AKA container) images, not all SBOM specifications include CVE information. Regardless, &quot;<code>trivy sbom ...FILE</code>&quot; of the SBOM file generated by &quot;<code>trivy image ... IMAGE</code>&quot; provides the detailed vulnerabilities audit.</p>

<pre><code class="language-plaintext">-f, --format string   format(table,json,template,sarif,cyclonedx,spdx,spdx-json,github,cosign-vuln) (default table)
</code></pre>

<ol>
<li><strong>SPDX</strong> (Software Package Data Exchange) :<br>
SPDX is an open standard for sharing information about software package <strong>licenses, copyrights and such <def title="Open Source Software">OSS</def> tracking</strong>. It is widely used for creating and sharing SBOMs. Originally developed by the Linux Foundation.

<ul>
<li><code>trivy image --format spdx-json ...</code></li>
</ul></li>

<li><p><strong>CycloneDX</strong> :<br>
CycloneDX is another SBOM standard focused on <strong>security and software component and supply chain audit</strong>. Created by the <a href="https://owasp.org/www-project-cyclonedx/" title="OWASP.org">OWASP Foundation</a>.</p>

<ul>
<li><p><code>trivy image --format cyclonedx ...</code></p>

<pre><code class="language-json">...
&quot;description&quot;: &quot;The grafana plugin SDK bundles build metadata into ... including said credentials.&quot;,
&quot;recommendation&quot;: &quot;Upgrade github.com/grafana/grafana-plugin-sdk-go to version 0.250.0&quot;,
&quot;advisories&quot;: [
    ...
    {
        &quot;url&quot;: &quot;https://grafana.com/security/security-advisories/cve-2024-8986&quot;
    },
    ...
    {
        &quot;url&quot;: &quot;https://nvd.nist.gov/vuln/detail/CVE-2024-8986&quot;
    },
    ...
],
...
</code></pre></li>
</ul></li>

<li><p><strong>SARIF</strong> (Static Analysis Results Interchange Format) :<br>
SARIF is a standard format developed by <a href="https://groups.oasis-open.org/communities/">OASIS</a> for reporting the results of <strong>static code analysis</strong> tools. It focuses on security vulnerabilities and code quality issues rather than an SBOM. SARIF <strong>does not include an SBOM</strong>. It is primarily for representing the results of vulnerability scanning in a way that can be consumed by other security tools.</p></li>

<li><p><strong>Cosign-vuln</strong> :<br>
Cosign is part of the <a href="https://www.sigstore.dev/">Sigstore project</a> and is used <strong>for signing container images</strong> and verifying their integrity; <strong>attestations</strong>. The &quot;<code>cosign-vuln</code>&quot; format is used to integrate vulnerability scanning results with Cosign's signing and verification workflow. Cosign-vuln format <strong>does not include an SBOM</strong>. It's primarily focused on vulnerability reporting and container image signing.</p></li>
</ol>

<p>Other SBOM standards:</p>

<ul>
<li><a href="https://github.com/anchore/syft">Syft</a> :<br>
Purely an SBOM generator; its own widely-adopted standard.

<ul>
<li><code>trivy sbom ...</code> parse/analyze Syft SBOMs</li>
</ul></li>
<li><a href="https://github.blog/enterprise-software/governance-and-compliance/introducing-self-service-sboms/">GitHub's Dependency Snapshot</a> :<br>
Purely an SBOM generator; widely-adopted, NTIA-compliant standard.

<ul>
<li><code>trivy image --format github ...</code> generates SBOM of that format</li>
</ul></li>
</ul>

<h3>SBOMs : Trivy v. <a href="https://github.com/anchore/syft">Syft</a></h3>

<p>Syft does not include vulnerabilities. It's purely SBOM.
Syft appears to capture more components, yet less dependencies than Trivy:</p>

<pre><code class="language-bash"># Install Syft
☩ curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sudo sh -s -- -b /usr/local/bin
# Syft scan
☩ syft scan $image -o cyclonedx-json=$sbom.syft.cdx.json

# @ Syft 
☩ cat $sbom.syft.cdx.json |jq .components |wc -l
28132
☩ cat $sbom.syft.cdx.json |jq .dependencies |wc -l
641

# @ Trivy
☩ cat $sbom.cdx.json |jq .components |wc -l
9143
☩ cat $sbom.cdx.json |jq .dependencies |wc -l
2505

</code></pre>

<h3>SBOM / Audit : SPDX v. CycloneDX</h3>

<p>The output of a Trivy scan of a container image, &quot;<code>trivy image ...</code>&quot;,
by either of these two DX formats includes the image's SBOM.</p>

<p>The output of a Trivy scan of an SBOM (file), &quot;<code>trivy sbom ...</code>&quot;,
also includes the image's SBOM.</p>

<p>Regardless of format, all SBOMs contain much the same information.
However, their specified keys differ.
For example, CycloneDX key <code>vulnerabilities[].advisories[].url</code>
is SPDX key <code>packages[].externalRefs[].referenceLocator</code>,
yet Trivy (default, non-standard) SBOM key <code>Results[].Vulnerabilities[].PrimaryURL</code>.</p>

<h4>Naming Convention</h4>

<p>For <code>FILE</code>s of a <strong>container-image scan</strong> :</p>

<pre><code class="language-bash"># trivy image ... -o FILE ... IMAGE 
[$registry[_$port].][.$repo.]${app}_${tag}.sbom.$spec.$ext`
</code></pre>

<ul>
<li>These files contain (among other sections) an SBOM of either<br>
a declared specification
(<code>cdx</code> for CycloneDX, or <code>spdx</code> for SPDX),<br>
or of Trivy's non-standard default (<code>trivy</code>).</li>
</ul>

<p>For <code>FILE</code>s of a <strong>CVEs audit of an SBOM file</strong> :</p>

<pre><code class="language-bash"># trivy sbom ... -o FILE ... SBOM_FILE
[$registry[_$port].][.$repo.]${app}_${tag}.sbom.$spec.audit.$ext`
</code></pre>

<ul>
<li><p>These files contain both the format-compliant SBOM<br>
and a detailed vulnerability audit based on that.</p>

<pre><code class="language-bash">image=docker.io/grafana/grafana:11.2.0
image=python:3.12.6
sbom=${image////.};sbom=${sbom//:/_}.sbom
severity='--severity CRITICAL,HIGH'
tpl_keys=_trivy.image.template.json
tpl=_trivy.image.template_to_table.tpl

# Scan for CVEs of $severity, and log resulting (non-standard) SBOM in (default) table format
trivy image --scanners vuln $severity --format table -o $sbom.trivy.log $image 

# Scan for same, but SBOM in JSON format
trivy image --scanners vuln $severity --format json -o $sbom.trivy.json $image 

# Scan for same, but SBOM in SPDX (table) format 
trivy image --scanners vuln $severity --format spdx -o $sbom.spdx.log $image 

# Scan for same, but SBOM in SPDX-JSON (JSON) format
trivy image --scanners vuln $severity --format spdx-json -o $sbom.spdx.json $image 

# Scan for same, but SBOM in CycloneDX (JSON) format
trivy image --scanners vuln $severity --format cyclonedx -o $sbom.cdx.json $image 
## Convert to YAML
cat $sbom.cdx.json |yq -P -o=yaml eval |tee $sbom.cdx.yaml &gt;/dev/null

# Scan for same, but SBOM in github (JSON) format
trivy image --scanners vuln $severity --format github -o $sbom.github.json $image 

# Scan for same, but into custom template
## 1. Muster/Discover all keys of `--format template` into JSON.
##    Using jq here to filter out all key values and array elements of type: string, allowing only all (sub)keys.
trivy image --scanners vuln --format template --template '{{ toJson . }}' $image |jq -Mr 'walk(
if type == &quot;object&quot; then
    with_entries(.value |= if type == &quot;object&quot; or type == &quot;array&quot; then . else &quot;&quot; end)
elif type == &quot;array&quot; then
    map(select(type != &quot;string&quot;))
else
    .
end
)' |tee $tpl_keys
## For same of `--format json` struct (Trivy's default, non-standard SBOM) :
trivy image --scanners vuln $image --format json |jq -Mr 'walk(...)' |tee _trivy.image.trivy.json
## 2. Create template (Golang syntax) based on discovered keys of all available. (See $template of step 1.)
vi $tpl
## 3. Scan into custom template
trivy image --scanners vuln $severity $image --format template --template &quot;@$tpl&quot; -o $sbom.trivy.template.log
</code></pre></li>

<li><p>SBOM : image scan results include SBOM</p>

<ul>
<li>Non-standard <code>trivy image --format json ...</code> <strong>has remediation-related info</strong>;<br>
<code>&quot;Title&quot;: &quot;...&quot;</code>, <code>&quot;Description&quot;: &quot;...&quot;</code>, <code>&quot;References&quot;: [&quot;url&quot;: &quot;...&quot;, ...]</code>.<br>

<ul>
<li>JSON keys of <code>--format template</code> <strong>differ</strong> from those of <code>--format json</code>.<br></li>
</ul></li>
<li>SPDX<br>

<ul>
<li><code>trivy image --format spdx-json ...</code>;<br>
<strong>no remediation-related info</strong> whatsoever.<br>
That standard is strictly about capturing OSS-related info and security vulnerabilies.<br></li>
</ul></li>
<li>CycloneDX

<ul>
<li><p><code>trivy image --format cyclonedx ...</code> <strong>has remidiation-related info</strong>;</p>

<pre><code class="language-json">    ...
    &quot;vulnerabilities&quot;: [
        {
        &quot;id&quot;: &quot;CVE-2024-34156&quot;,
        &quot;source&quot;: {
            &quot;name&quot;: &quot;...&quot;, &quot;url&quot;: &quot;https://pkg.go.dev/vuln/&quot;
        },
        &quot;ratings&quot;: [
            { &quot;severity&quot;: &quot;high&quot;, ...}, &quot;score&quot;: 7.5, ...},
            ...
        ],
        &quot;description&quot;: &quot;...&quot;,
        &quot;recommendation&quot;: &quot;...&quot;,
        &quot;advisories&quot;: [
            ...
            { &quot;url&quot;: &quot;https://access.redhat.com/security/cve/CVE-2024-34156&quot; },
            ...
            { &quot;url&quot;: &quot;https://www.cve.org/CVERecord?id=CVE-2024-34156&quot; }
        ],
        ...
</code></pre>

<ul>
<li><code>advisories</code> of CycloneDX SBOM maps to <code>References</code> of its SBOM audit.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>&nbsp;</p>

<p>Not all SBOM standards include vulnerability audit. Syft for example.
Use &quot;<code>trivy sbom ...</code>&quot; on that or any other SBOM <strong>file</strong>
to obtain <strong>detailed vulnerability audit</strong> based on its SBOM.
Output of Trivy's <code>sbom</code> command includes the input SBOM by default.</p>

<pre><code class="language-bash"># Analyze non-standard (trivy) SBOM file : FAILing
trivy sbom $severity $sbom.trivy.json -o $sbom.trivy.audit.log
trivy sbom $severity $sbom.trivy.json --format json -o $sbom.trivy.audit.json

# Analyze SBOM of SPDX file 
trivy sbom $severity $sbom.spdx.json -o $sbom.spdx.audit.log
trivy sbom $severity $sbom.spdx.json --format json -o $sbom.spdx.audit.json

# Analyze SBOM of CycloneDX file 
trivy sbom $severity $sbom.cdx.json -o $sbom.cdx.audit.log 
trivy sbom $severity $sbom.cdx.json --format json -o $sbom.cdx.audit.json

</code></pre>

<ul>
<li>Vulnerability audit of SPDX and CycloneDX compliant SBOMs are <strong>identical</strong>,
except for meta-key values:
<code>ArtifactType</code>, <code>ArtifactName</code>, <code>Target</code>, <code>UID</code>, <code>BOMRef</code>.
And the only significant difference there is that <code>BOMRef</code> of SPDX
is of form &quot;<code>pkg:path/to/sdk@version</code>&quot;,
whereas that of CycloneDX is a UUID (v4).

<ul>
<li>Non-standard :

<ul>
<li>Audit FAILs</li>
</ul></li>
<li>SPDX

<ul>
<li><strong>has remidiation-related info</strong>, but <strong>keys are refactore</strong>d.
E.g., <code>referenceLocator</code> (of <code>spdx</code>) maps to <code>PrimaryURL</code></li>
</ul></li>
<li>CycloneDX

<ul>
<li><strong>has remidiation-related info</strong>, but <strong>keys are refactored</strong>.
E.g., <code>recommendation</code> (of <code>cdx</code>) maps to <code>PrimaryURL</code>
<br></li>
</ul></li>
</ul></li>
</ul>

<h4>Refactor CycloneDX SBOM/Audit</h4>

<p>Filter out all keys not required for remediation AKA mitigation :</p>

<pre><code class="language-bash">image=docker.io/grafana/grafana:11.2.0
#image=python:3.12.6
sbom=${image////.};sbom=${sbom//:/_}
severity='--severity CRITICAL,HIGH'

## Create SBOM 
sbom=$sbom.cdx.json
trivy image --scanners vuln $severity $image --format cyclonedx -o $sbom

## Filter SBOM 
# out=$sbom.cdx.filtered
# cat $sbom.cdx.json |jq -Mr '{
#     About: &quot;Filtered CycloneDX-compliant SBOM created by Trivy scan of a container image.&quot;,
#     Image: .metadata.component.name,
#     Scan: &quot;'&quot;trivy image --scanners vuln $severity $image --format cyclonedx -o $sbom&quot;'&quot;,
#     Source: &quot;'$sbom'&quot;,
#     Date: &quot;'$(date -u --iso-8601=seconds)'&quot;,
#     CVEs: [
#         .vulnerabilities[]? | {
#             &quot;ID&quot;: .id,
#             &quot;Severity&quot;: (.ratings | map({&quot;source&quot;:.source.sbom,&quot;severity&quot;:.severity}) // []),
#             &quot;Description&quot;: .description,
#             &quot;Recommendation&quot;: (.recommendation // &quot;See Advisories.&quot;),
#             &quot;Advisories&quot;: (.advisories // []) | map(.url)
#         }
#     ]
# }' |tee $out.json

## Audit SBOM and filter the audit.
audit=$sbom.cdx.audit.json
out=$sbom.cdx.audit.filtered
# trivy sbom $severity $sbom --format json -o $audit
trivy sbom $severity --format json $sbom.cdx.json |jq -Mr '{
    Image: .ArtifactName,
    CVEs: .Results | .[]?
} | {
    About: &quot;Filtered CVEs audit of a CycloneDX-compliant SBOM file.&quot;,
    Image: &quot;'$image'&quot;, 
    SBOM: &quot;'$sbom.cdx.json'&quot;,
    Audit: &quot;trivy sbom '&quot;--scanners vuln $severity --format json &lt;SBOM&gt;&quot;'&quot;,
    Date: &quot;'$(date -u --iso-8601=seconds)'&quot;,
    CVEs: {
        Vulnerabilities: [
            .CVEs.Vulnerabilities[]? | select(. != null and .VulnerabilityID != null) | {
                ID: .VulnerabilityID,
                Severity: .Severity,
                Title: .Title,
                Description: .Description,
                PkgName: .PkgName,
                PkgVersionInstalled: .InstalledVersion,
                PkgVersionFixed: (.FixedVersion // &quot;N.A&quot;),
                Status: .Status,
                PrimaryURL: .PrimaryURL,
                References: .References
            }
        ] 
    }
} | select(.CVEs.Vulnerabilities | length &gt; 0)' \
    |tee $out.json \
    |yq -P -o=yaml eval \
    |tee $out.yaml \
    &gt;/dev/null

rm $sbom.cdx.json

</code></pre>

<h2>Containerized Trivy</h2>

<h3><a href="https://aquasecurity.github.io/trivy-operator/latest/">K8s : <code>trivy-operator</code></a></h3>

<p>The Trivy Operator automatically discovers and scans all images running in a K8s cluster, including images of application pods and system pods. Scan reports are summarized and saved as <code>VulnerabilityReport</code> (CRD) resources, which are owned by a Kubernetes controller.</p>

<p>Install by Helm</p>

<pre><code class="language-bash">ver='0.24.1' # trivy v0.22.0
helm repo add trivy-operator https://aquasecurity.github.io/helm-charts/
helm upgrade --install trivy trivy-operator/trivy-operator --version $ver
</code></pre>

<ul>
<li><p>Images :</p>

<pre><code class="language-plaintext">ghcr.io/aquasecurity/trivy
ghcr.io/aquasecurity/trivy-operator
ghcr.io/aquasecurity/node-collector
ghcr.io/aquasecurity/trivy-db
ghcr.io/aquasecurity/trivy-java-db
</code></pre></li>
</ul>

<p>&nbsp;
Scan reports saved to CRD: <code>kind: VulnerabilityReport</code></p>

<pre><code class="language-bash">k get VulnerabilityReport 

vr=statefulset-my-vault-vault

k -n vault get VulnerabilityReport $vr -o json \
    |jq -Mr '.report.vulnerabilities | .[]? |select(.severity == &quot;CRITICAL&quot; or .severity == &quot;HIGH&quot;)'
    |jq . --slurp
</code></pre>

<pre><code class="language-json">[
  {
    &quot;fixedVersion&quot;: &quot;23.0.15, 26.1.5, 27.1.1, 25.0.6&quot;,
    &quot;installedVersion&quot;: &quot;v25.0.5+incompatible&quot;,
    &quot;lastModifiedDate&quot;: &quot;2024-07-30T20:15:04Z&quot;,
    &quot;links&quot;: [],
    &quot;primaryLink&quot;: &quot;https://avd.aquasec.com/nvd/cve-2024-41110&quot;,
    &quot;publishedDate&quot;: &quot;2024-07-24T17:15:11Z&quot;,
    &quot;resource&quot;: &quot;github.com/docker/docker&quot;,
    &quot;score&quot;: 9.9,
    &quot;severity&quot;: &quot;CRITICAL&quot;,
    &quot;target&quot;: &quot;&quot;,
    &quot;title&quot;: &quot;moby: Authz zero length regression&quot;,
    &quot;vulnerabilityID&quot;: &quot;CVE-2024-41110&quot;
  },
  {
    ...
    &quot;severity&quot;: &quot;HIGH&quot;,
    &quot;target&quot;: &quot;&quot;,
    &quot;title&quot;: &quot;encoding/gob: golang: Calling Decoder.Decode ... can cause a panic due to stack exhaustion&quot;,
    &quot;vulnerabilityID&quot;: &quot;CVE-2024-34156&quot;
  }
]
</code></pre>

<h3>Docker</h3>

<pre><code class="language-bash">
trivy=aquasec/trivy:0.52.2
subject=docker.io/grafana/grafana:11.2.0
sbom=${subject////.}
sbom=${sbom//:/_}.sbom.cdx.json

docker run --rm \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v /tmp/trivy:/root/.cache/ \
    -v $(pwd):/tmp \
    $trivy image -q \
        --scanners vuln \
        --format cyclonedx \
        -o /tmp/$sbom\
        $subject

</code></pre>

<ul>
<li><code>--rm</code> : Delete container upon completion.</li>
<li><code>-v /var/...</code> : Bind mount to host's Docker-server socket.</li>
<li><code>-v /tmp/...</code> : Bind mount to an empty host store to persist Trivy's DB download(s).</li>
</ul>

<h3><a href="https://chatgpt.com/share/66fc84d8-9804-8009-a091-c4b6ed94aabc" title="ChatGPT.com">Advanced Docker Configuration</a> : Rootless</h3>

<p>Trivy running as a container (above) has a bind mount to Docker's socket (<code>/var/run/docker.sock</code>) to provide the required communication to Docker API for pulling images, examining layers and such; however, that's a big security issue because the container must then run as root. A more secure arrangement (if by TLS) is to connect via TCP using Trivy flag <code>--docker-host</code>. Note we're configuring for Trivy to <strong>run as non-root user</strong>, which is a security boost regardless.</p>

<p>To implement this, configure the Docker daemon to listen on the host's common interface (<code>eth0</code>) rather than to whatever file descriptor (<code>fd</code>) is passed by systemd.</p>

<h4>1. Get host address</h4>

<p>Want Docker API available via host interface.</p>

<pre><code class="language-bash">$ ip -4 -brief addr 
lo               UNKNOWN        127.0.0.1/8 10.255.255.254/32
eth0             UP             172.27.240.169/20
docker0          DOWN           172.17.0.1/16
</code></pre>

<h4>2. Reconfigure Docker server (daemon)</h4>

<pre><code class="language-bash">ifc=172.27.240.169
cat &lt;&lt;-EOH |sudo tee /etc/docker/daemon.json
{
    &quot;hosts&quot;: [
        &quot;tcp://$ifc:2375&quot;,
        &quot;unix:///var/run/docker.sock&quot;
    ]
}
EOH
</code></pre>

<p>Verify the configuation file</p>

<pre><code class="language-bash"># Validate the configuration 
sudo systemctl stop docker.service
sudo dockerd --config-file /etc/docker/daemon.json
</code></pre>

<h4>3. Reconfigure <code>docker.service</code></h4>

<p>Remove the <code>-H fd://</code> flag, which allows for file descriptor (<code>fd</code>) passing and is used in the systemd environment to tell Docker to listen on a socket activated by systemd. We rather declare its listening socket  in the Docker daemon's config <code>/etc/docker/daemon.json</code>.</p>

<p>Use a drop-in file, leaving the default unit file unaltered.
That is the advised method for managing systemd unit-file configurations.</p>

<pre><code class="language-bash"># Override the default unit file by adding a drop-in file
sudo mkdir -p /etc/systemd/system/docker.service.d

cat &lt;&lt;-EOH |sudo tee /etc/systemd/system/docker.service.d/override.conf
[Service]
ExecStart=
ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock
EOH

sudo systemctl daemon-reload
sudo systemctl restart docker
sudo systemctl status docker

</code></pre>

<h4>4. Declare <code>TRIVY_CACHE_DIR</code></h4>

<p>Trivy's default cache directory is <code>/root/.cache</code>, which requires root user.
Yet this may be set to that accessible by non-root user.</p>

<p>Now we're ready.</p>

<h5>Run containerized Trivy as non-root (<code>UID:GID</code>)</h5>

<pre><code class="language-bash">ifc=172.27.240.169
ctnr_cache=/tmp/trivy_cache
ctnr_work=/mnt/trivy_work
trivy=aquasec/trivy:0.52.2
subject=docker.io/grafana/grafana:11.2.0
sbom=${subject////.}
sbom=${sbom//:/_}.sbom.cdx.json

docker run --rm \
    -e TRIVY_CACHE_DIR=$ctnr_cache \
    -v /tmp/trivy:$ctnr_cache \
    -v $(pwd):$ctnr_work \
    --user 1000:1000 \
    $trivy image \
        --scanners vuln \
        --docker-host tcp://$ifc:2375 \
        --format cyclonedx \
        -o $ctnr_work/$sbom \
        $subject

</code></pre>

<h4>Secure by TLS</h4>

<p>@ <code>/etc/docker/daemon.json</code></p>

<pre><code class="language-bash">ifc=172.27.240.169
cat &lt;&lt;-EOH |sudo tee /etc/docker/daemon.json
{
    &quot;hosts&quot;: [
        &quot;tcp://$ifc:2375&quot;,
        &quot;unix:///var/run/docker.sock&quot;
    ],
    &quot;tls&quot;: true,
    &quot;tlsverify&quot;: true,
    &quot;tlscacert&quot;: &quot;/etc/docker/certs.d/ca.pem&quot;,
    &quot;tlscert&quot;: &quot;/etc/docker/certs.d/server-cert.pem&quot;,
    &quot;tlskey&quot;: &quot;/etc/docker/certs.d/server-key.pem&quot;
}
EOH

docker run --rm \
    -v /path/to/certs:/etc/docker/certs.d \
    -e DOCKER_HOST=tcp://$ifc:2376 \
    -e DOCKER_TLS_VERIFY=1 \
    -e DOCKER_CERT_PATH=/etc/docker/certs.d \
    ...
</code></pre>
 
    </main>

    <script src="https://sempernow.github.io/refpages/sa/js/base.js"></script>
    <script>
        ;(function(o, undefined){
            'use strict'
            window.addEventListener('load', () => {
                ;(() => {})//()
                ;(() => {})//()
                ;(() => { // FOO LAB
                    const log = o.log('foo')
                        ,main = o.css('MAIN')
                    log('foo')
                    o.toDOM(main, '<h1>TEST</h1>')
                })//()
            })
        })( (typeof window !== 'undefined') 
            && (window[__APP__] = window[__APP__] || {})
                || (typeof global !== 'undefined') 
                    && (global[__APP__] = global[__APP__] || {})
        );
    </script>
</body>
</html>
