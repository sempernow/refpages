<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>CSRF.XSRF</title>
    <link rel="icon" href="https://sempernow.github.io/refpages/sa/favicon.png">
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/normalize.css">
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/main.css">
    <!--
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/dev.css">
    -->
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/hljs.github.min.css">
    <style>

    </style>
    <script src="https://sempernow.github.io/refpages/sa/js/hl.min.js"></script>
    <script>hljs.highlightAll()</script>
</head>
<body>
    <main>
        <h1><a href="https://owasp.org/www-community/attacks/csrf" title="OWASP.org">CSRF</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" title="Cross-origin Resource Sharing @ MDN"><code>CORS</code></a></h1>

<blockquote>
<p><a href="https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2017/september/common-csrf-prevention-misconceptions/" title="nccgroup.com"><em>CORS Is Not a CSRF Prevention Mechanism.</em></a> &hellip; <em>Any request generated by an HTML form will necessarily be a</em> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests" title="MDN"><em>simple request</em></a> <em>and will never be preflighted. Form submissions can be sent from any origin to any other origin. &hellip; While a properly configured CORS policy is important, it does not in itself constitute a CSRF defense.</em></p>
</blockquote>

<h2>Scenario</h2>

<ol>
<li>The target, Joe, is logged into their account at <code>https://bank.com</code>.</li>
<li>The target then visits the web site of the perp, Tom, at <code>https://foo.com</code>.</li>
<li>Tom places the <em>malicious URL at his own site</em> exploiting the fact that Tom is logged in at the  <code>bank.com</code> site.</li>
</ol>

<p>The perp knows the proper <code>bank.com</code> URL for requesting a transfer of money from Joe's account into Tom's account &hellip;</p>

<pre><code class="language-html">&lt;a href=&quot;https://bank.com/transfer.do?acct=TOM&amp;amount=100000&quot;&gt;View my Pictures!&lt;/a&gt;
</code></pre>

<p>Or as a 0x0 fake image:</p>

<pre><code class="language-html">&lt;img src=&quot;https://bank.com/transfer.do?acct=TOM&amp;amount=100000&quot; width=&quot;0&quot; height=&quot;0&quot; border=&quot;0&quot;&gt;
</code></pre>

<p>The server does not know <strong><em>this is a cross-origin request</em></strong> because it <em>fails to match request header</em> <code>Referer</code> against that of <code>Host</code>, and so allows the exploit.</p>

<h2><a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html" title="owasp.org">Mitigate</a></h2>

<ul>
<li><p><strong><em>Validate request headers</em></strong>; either &quot;<code>Referer</code>&quot; or &quot;<code>Origin</code>&quot;, matching the value against that of &quot;<code>Host</code>&quot; request header.</p>

<ul>
<li><p>Strong test, i.e., test against host string of <code>//foo.com/</code>, not merely <code>/foo.com</code> or worse still <code>foo.com</code>, which may be of origin <code>foo.com.bad.com</code>.</p>

<pre><code class="language-golang">if !strings.Contains(r.Referer(), &quot;//&quot;+r.Host) &amp;&amp; r.Referer() != &quot;&quot; {
    err = errors.New(&quot;no hotlinks&quot;)
}
</code></pre></li>
</ul></li>

<li><p>Enforce Same-site policy</p>

<ul>
<li>No CORS, or tightly controlled, server-side</li>
<li>Cookie set per &quot;<code>SameSite: strict</code>&quot;</li>
</ul></li>

<li><p>Prevent <a href="https://owasp.org/www-community/attacks/xss/" title="OWASP.org">XSS</a> using <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" title="Content Security Policy @ MDN">CSP</a> HTTP header along with <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity" title="MDN">Subresource Integrity (nonces)</a></p></li>

<li><p>Use <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#use-of-custom-request-headers">Custom Request Headers</a></p>

<ul>
<li>By default, browsers do not allow scripts (JS) to make cross-origin requests with custom headers.</li>
</ul></li>

<li><p><a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern">CSRF (Synchronizer) Token</a></p></li>

<li><p><em>Stateless CSRF mitigation</em> a.k.a. <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie"><em>Double Submit Cookie</em></a> method.</p>

<ul>
<li>Server sends nonce with HTML form per hidden form key attribute and/or HTTP header, which client returns with the subsequent POST request per <strong><em>both</em></strong> request parameter (e.g., form key value) and HTTP header (<code>X-CSRF-Token: 1qlkhh12u15...</code>); validate per match <strong><em>and</em></strong> same-site tests.</li>
</ul></li>
</ul>

<h3>&nbsp;</h3>

<!-- 

# Markdown Cheatsheet

[Markdown Cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet "Wiki @ GitHub")


# Link @ (MD | HTML)

([MD](___.html "@ browser"))   


# Bookmark

- Reference
[Foo](#foo)
- Target
<a name="foo"></a>

-->
 
    </main>

    <script src="https://sempernow.github.io/refpages/sa/js/base.js"></script>
    <script>
        ;(function(o, undefined){
            'use strict'
            window.addEventListener('load', () => {
                ;(() => {})//()
                ;(() => {})//()
                ;(() => { // FOO LAB
                    const log = o.log('foo')
                        ,main = o.css('MAIN')
                    log('foo')
                    o.toDOM(main, '<h1>TEST</h1>')
                })//()
            })
        })( (typeof window !== 'undefined') 
            && (window[__APP__] = window[__APP__] || {})
                || (typeof global !== 'undefined') 
                    && (global[__APP__] = global[__APP__] || {})
        );
    </script>
</body>
</html>
