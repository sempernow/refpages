<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Auth.AD.ADFS.Linux</title>
    <link rel="icon" href="https://sempernow.github.io/refpages/sa/favicon.png">
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/normalize.css">
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/main.css">
    <!--
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/dev.css">
    -->
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/hljs.github.min.css">
    <style>

    </style>
    <script src="https://sempernow.github.io/refpages/sa/js/hl.min.js"></script>
    <script>hljs.highlightAll()</script>
</head>
<body>
    <main>
        <h1>Active Directory (AD) : AD Federated Services (ADFS) : Linux Integration</h1>

<h2><a href="https://chatgpt.com/share/73401243-5ea0-4cdc-9090-d6dd709ada10?oai-dm=1">Active Directory [AD] [AD FS] : Linux Integration [Keycloak] : Group Management</a></h2>

<blockquote>
<p>A group may be created using some federated authentication scheme such as Active Directory, affecting many machines of a domain, for which the command &quot;<code>sudo usermod -aG $group $user</code>&quot; does not work. How is such a group created on each machine thereof?</p>
</blockquote>

<p>In environments where Active Directory (AD) or other types of federated authentication systems are used, group management is typically centralized rather than handled on each individual machine. Here’s how the process generally works:</p>

<ol>
<li><p>Centralized Group Management</p>

<p>Groups are managed centrally within Active Directory. This means you create, modify, and delete groups directly in the AD domain controller, not on individual machines. This centralized management approach allows changes to be propagated automatically to all machines within the domain that are connected to AD.</p></li>

<li><p>Group Creation in Active Directory</p>

<p>To create a group in Active Directory:</p>

<p>&vellip;&nbsp;</p></li>
</ol>

<p>&nbsp;&vellip;&nbsp;</p>

<blockquote>
<p>Is there a favored software package for this on RHEL 8/9 machines?
ChatGPT</p>
</blockquote>

<p>For RHEL (Red Hat Enterprise Linux) 8 and 9, the preferred method for integrating with Active Directory is using SSSD (System Security Services Daemon). SSSD provides a set of daemons to manage access to remote directories and authentication mechanisms. It also enhances the system's integration with various identity and authentication providers like Active Directory, LDAP, Kerberos, and others.</p>

<p>&vellip;&nbsp;</p>

<pre><code class="language-bash">sudo dnf install -y sssd realmd oddjob oddjob-mkhomedir adcli samba-common-tools
</code></pre>

<ul>
<li><p>@ <code>/etc/pam.d/common-session</code></p>

<pre><code class="language-conf">session optional pam_mkhomedir.so skel=/etc/skel umask=0077
</code></pre></li>
</ul>

<p>&vellip;&nbsp;</p>

<blockquote>
<p>Is there a preferred way to integrate this into K8s to provide  SSO capability to web services?</p>
</blockquote>

<p>Integrating Single Sign-On (SSO) capability into Kubernetes (K8s) for web services, particularly those authenticated through Active Directory (AD), involves several components. These are typically focused on using open standards like SAML, OpenID Connect (OIDC), or OAuth. Here are the general steps and technologies you might use to achieve this:</p>

<ol>
<li>Kubernetes Authentication</li>
</ol>

<p>Kubernetes itself doesn't handle user authentication at the application level directly. Instead, it relies on external identity providers (IdPs). For AD, this often means using a solution that can interface with OIDC or SAML.</p>

<ol>
<li><p>Choosing an Identity Provider (IdP) for Active Directory:</p>

<ul>
<li><strong>Active Directory Federation Services</strong> (AD FS): This is a Windows Server role that <strong>provides SSO capabilities</strong> and can be used to set up a federation with your Kubernetes clusters using <strong>SAML</strong> or <strong>OIDC</strong>.</li>
<li>Azure Active Directory: If you're using Azure, you can integrate Azure AD with Kubernetes, which supports OIDC natively.</li>
<li>Third-Party <strong>IdPs</strong>: Tools like <strong>Okta</strong>, <strong>Auth0</strong>, or <strong>Keycloak</strong> can integrate with AD and provide OIDC or SAML tokens to Kubernetes.</li>
</ul></li>
</ol>

<p>&vellip;&nbsp;</p>

<p>In your scenario, where most applications are running on Kubernetes or Linux while Active Directory (AD) and Microsoft's certificate server run on Windows, using Keycloak in addition to AD can be advantageous over AD FS alone. Here’s why:</p>

<p>&vellip;&nbsp;</p>

<h2><a href="https://chatgpt.com/share/86673db4-299c-4f5d-8c0b-51bfa6e1ba5f">AD to K8s Integration Guide : ADFS [OIDC/Backend of IdP] to Dex [IdP] to OAuth2 Proxy to Apps</a></h2>

<p>To implement user authentication for applications running on a Kubernetes cluster using Active Directory (AD) as the authentication mechanism, you can use a combination of Kubernetes-native and external tools to integrate with AD. Here’s a comprehensive approach:</p>

<ol>
<li><p>Integrate Kubernetes with Active Directory<br>
Use <strong>OpenID Connect</strong> (OIDC)</p>

<ol>
<li><p>Configure Active Directory Federation Services (AD FS):<br>
Set up AD FS to act as an OpenID Connect provider.
Register your Kubernetes API server as a relying party (RP) or client in AD FS.</p></li>

<li><p>Configure Kubernetes API Server:<br>
Set the OIDC flags on the API server to use AD FS as the identity provider:</p>

<pre><code class="language-yaml">--oidc-issuer-url=https://your-adfs-server/adfs
--oidc-client-id=your-kubernetes-client-id
--oidc-username-claim=name
--oidc-groups-claim=groups
</code></pre></li>

<li><p>Install and Configure Dex:<br>
Dex is an OIDC Identity Provider that can authenticate against AD.<br>
Deploy Dex in your Kubernetes cluster.<br>
Configure Dex to use AD as a backend:
Example configuration:</p>

<pre><code class="language-yaml">connectors:
- type: ldap
id: ldap
name: Active Directory
config:
    host: &quot;ad.yourdomain.com:636&quot;
    bindDN: &quot;cn=service_account,dc=yourdomain,dc=com&quot;
    bindPW: &quot;password&quot;
    userSearch:
    baseDN: &quot;dc=yourdomain,dc=com&quot;
    filter: &quot;(objectClass=person)&quot;
    username: &quot;sAMAccountName&quot;
    idAttr: &quot;DN&quot;
    emailAttr: &quot;mail&quot;
    nameAttr: &quot;cn&quot;
    groupSearch:
    baseDN: &quot;dc=yourdomain,dc=com&quot;
    filter: &quot;(objectClass=group)&quot;
    userMatchers:
        - userAttr: &quot;DN&quot;
        groupAttr: &quot;member&quot;
    nameAttr: &quot;cn&quot;
</code></pre></li>
</ol></li>

<li><p>Integrate Applications with Active Directory<br>
Use <strong>OAuth2 Proxy</strong></p>

<ol>
<li><p>Deploy OAuth2 Proxy:
OAuth2 Proxy can handle authentication using OIDC tokens<br>
and act as a reverse proxy for your applications.<br>
Deploy OAuth2 Proxy in your Kubernetes cluster.<br>
Configure OAuth2 Proxy to use Dex as the OIDC provider:</p>

<pre><code class="language-yaml">kind: Deployment
apiVersion: apps/v1
metadata:
    name: oauth2-proxy
spec:
    replicas: 1
    selector:
    matchLabels:
        app: oauth2-proxy
    template:
    metadata:
        labels:
        app: oauth2-proxy
    spec:
        containers:
        - name: oauth2-proxy
        image: quay.io/oauth2-proxy/oauth2-proxy:v7.0.0
        args:
        - --provider=oidc
        - --oidc-issuer-url=https://dex.yourdomain.com
        - --client-id=your-client-id
        - --client-secret=your-client-secret
        - --redirect-url=https://your-app.yourdomain.com/oauth2/callback
        - --cookie-secret=your-cookie-secret
        - --upstream=http://your-app:8080
</code></pre></li>

<li><p>Configure Your Applications:</p>

<ul>
<li>Ensure your applications are behind the OAuth2 Proxy.</li>
<li><strong>Redirect</strong> users to the OAuth2 Proxy for authentication.</li>
</ul></li>
</ol></li>

<li><p>Managing Role-Based Access Control (RBAC)<br>
Create RBAC Roles and Bindings:</p>

<ul>
<li><p>Define roles and role bindings in Kubernetes
to map AD group memberships to Kubernetes roles:</p>

<pre><code class="language-yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
namespace: default
name: read-only
rules:
- apiGroups: [&quot;&quot;]
resources: [&quot;pods&quot;]
verbs: [&quot;get&quot;, &quot;list&quot;]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
name: read-only-binding
namespace: default
subjects:
- kind: Group
name: &quot;your-ad-group&quot;  # Name of the AD group
apiGroup: rbac.authorization.k8s.io
roleRef:
kind: Role
name: read-only
apiGroup: rbac.authorization.k8s.io
</code></pre></li>
</ul></li>
</ol>
 
    </main>

    <script src="https://sempernow.github.io/refpages/sa/js/base.js"></script>
    <script>
        ;(function(o, undefined){
            'use strict'
            window.addEventListener('load', () => {
                ;(() => {})//()
                ;(() => {})//()
                ;(() => { // FOO LAB
                    const log = o.log('foo')
                        ,main = o.css('MAIN')
                    log('foo')
                    o.toDOM(main, '<h1>TEST</h1>')
                })//()
            })
        })( (typeof window !== 'undefined') 
            && (window[__APP__] = window[__APP__] || {})
                || (typeof global !== 'undefined') 
                    && (global[__APP__] = global[__APP__] || {})
        );
    </script>
</body>
</html>
