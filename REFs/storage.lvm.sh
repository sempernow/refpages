#!/usr/bin/env bash
###############################################################
# LVM : Inspect|Create|Delete : DEVICE : VGs : LVs
# - Create an LVM-based data store for NFS (or any other use)
# - Idempotent
###############################################################
[[ $(whoami) == 'root' ]] || exit 1
dev="${2:-/dev/sdb}"
vg="${3:-data}"
lv="${4:-nfs1}"
mount="${5:-/srv/nfs/k8s}" # Export if NFS

[[ "${1,,}" == 'inspect' ]] || [[ $5 ]] || echo "
    USAGE : ${BASH_SOURCE##*/} {create,delete} DEVICE VG LV MOUNT || inspect [ DEVICE [VG] ] 
"

## UPDATE :

# Create a partition (safely) : Single partition on raw block device
dev=/dev/sdb
# 0. Partition if raw           (Partition)
blkid $dev |grep TYPE || {
    sudo parted -s $dev mklabel gpt
    sudo parted -s $dev mkpart pv 1MiB 100%
    sudo parted -s $dev set 1 lvm on
}
# Then create LVM Physical Volume:
pvcreate ${dev}1   

## PRIOR :

inspect(){
    [[ $1 ]] && {
        # Verbose, per : DEVICE [VG]
        pvdisplay $dev
        vgdisplay $vg
        lvm lvdisplay --maps $vg
        #lvm fullreport
        return
    }

    # Physical Volumes  (PVs)
    pvs

    # Volume Groups     (VGs)
    vgs

    # Logical Volumes   (LVs)
    lvs -a -o +devices

    # LVs per device
    lsblk;echo;lvscan
}

create(){
    # Create the Physical Volume  (PV)
    pvs $dev ||
        pvcreate $dev

    # Create the Volume Group     (VG)
    vgs $vg ||
        vgcreate $vg /dev/sdb

    # Create a Logical Volume     (LV) : Analogous to partition (fdisk)
    # A. Quick
    quick(){
        lvs $vg ||
            lvcreate -n $lv -l "100%FREE" $vg
            #... Logical Extents (LEs) keywork "100%FREE" uses all remaining unallocated extents of VG
    }
    #quick
    # B. Better
	wipefs -o 0 /dev/$vg/$lv > /dev/null 2>&1
    size=$(vgs --noheadings -o vg_free $vg |awk '{print $1}')
	[[ $size -ge 1 ]] && lvcreate -n $lv -L $(( $size - 1 ))G $vg # Leave 1G for future LVs
	[[ $size -ge 1 ]] || { echo "ERR : Insufficient space on VG: $vg" && return 111: }

    # Create FS : Format as XFS
    blkid /dev/$vg/$lv |grep xfs ||
        mkfs.xfs /dev/$vg/$lv

    # Create mount point and mount ephemerally
    mkdir -p $mount &&
        mount /dev/$vg/$lv $mount

    # Persist
    # 1. Get UUID
    blkid="$(blkid /dev/$vg/$lv |cut -d' ' -f2 |cut -d'=' -f2 |sed 's/"//g')"
    # 2. Append to /etc/fstab (once)
	cat /etc/fstab |grep $blkid || cat <<-EOH |tee -a /etc/fstab
	UUID=$blkid $mount xfs defaults 0 0
	EOH
    # 3. Apply changes to systemd srv-nfs-k8s.mount, 
    #    which is dynamically generated by systemd-fstab-generator
    systemctl daemon-reload &&
        systemctl cat srv-nfs-k8s.mount
    # 4. Mount and initialize
    mount -a &&
        chown -R nfsanon:ad-linux-users $mount
}

delete(){
    echo '⚠️⚠️⚠️  This will now DESTROY ALL DATA and LVM objects of "'$dev'" including "'/dev/$vg/$lv'"  ⚠️⚠️⚠️'
    echo 
    read -p "⚠️⚠️⚠️  Okay? [y/N] " n
    [[ ${n,,} != 'y' ]] && return 0
    clear

    # Unmount (if mounted)
    umount /dev/$vg/$lv 2>/dev/null || true

    # Remove the LV
    lvremove -y /dev/$vg/$lv

    # Remove the VG
    vgremove -y $vg

    # Remove the PV
    pvremove $dev

    # Wipe the disk signature (Optional) 
    wipefs -a $dev
    # Extra thoroughly (overwrite with 0s)
    dd if=/dev/zero of=$dev bs=1M count=10
    # If partitioned, may also wipe GPT/MBR headers
    sgdisk --zap-all $dev
}

"$@" || echo ERR $?
