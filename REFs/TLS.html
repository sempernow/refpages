<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>TLS</title>
    <link rel="icon" href="https://sempernow.github.io/refpages/sa/favicon.png">
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/normalize.css">
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/main.css">
    <!--
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/dev.css">
    -->
    <link rel="stylesheet" href="https://sempernow.github.io/refpages/sa/css/hljs.github.min.css">
    <style>

    </style>
    <script src="https://sempernow.github.io/refpages/sa/js/hl.min.js"></script>
    <script>hljs.highlightAll()</script>
</head>
<body>
    <main>
        <h1>TLS (Formerly SSL) | <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" title="Wikipedia">Wikipedia</a> | <a href="https://www.rfc-editor.org/rfc/rfc6066" title="IETF.org">RFC-6066</a> | <a href="https://www.rfc-editor.org/rfc/rfc8446" title="RFC-8446">TLS 1.3</a> | <a href="https://www.rfc-editor.org/rfc/rfc5246" title="RFC-5246">TLS 1.2</a></h1>

<h2>Overview</h2>

<p>TLS/SSL, &quot;Transport Layer Security&quot; FKA &quot;Secure Socket Layer&quot;, is a trust-based PKI (Public Key Infrastructure) scheme of HTTPS protocol, extending HTTP to secure the internet. The server sends a single cryptographically-generated certificate if signed by a root CA, else a chain of them. The client application validates each server certificate against the Certificate Authority (CA) that supposedly signed it.</p>

<p>Nominally, the client application has access to a <strong>trust store</strong> containing a list of trustworthy-CA certificates, which it uses to verify the (supposedly) CA-signed server certificate or chain of certificates. CAs are hierarchical, with intermediate-CA certificates forming a chain of trust from end-entity (server) certificate to the <a href="https://en.wikipedia.org/wiki/Root_certificate">root (CA) certificate</a>.</p>

<blockquote>
<p>A certificate's <code>Issuer</code> is the CA that signed that <code>Subject</code> certificate, so the root (CA) is always self-signed. However, the term &quot;<em>self-signed</em>&quot; more often references an end-entity certificate created sans CA. These are somewhat useful, but only for test/dev purposes. Care must be taken even within that scope because browsers and other clients respond entirely differently when the end-entity (server) certificate sent during the TLS handshake does not validate against any client-trusted CA.</p>
</blockquote>

<p><strong>POSIX</strong>-type operating systems have a directory of such certificate files. <strong>Linux</strong> stores them in the <strong><code>/etc/ssl/certs</code></strong> directory. The <strong><code>ca-certificates.crt</code></strong> file contains a concatenated list of such certificates. Other CA root-certificate files (<code>*.crt</code>) may exist in that directory as standalones, e.g., <code>root-ca-site.local.crt</code> .</p>

<p><strong>Windows</strong> has an entirely different scheme of course; <code>Certificates.msc</code></p>

<h3>TLS Handshake</h3>

<p><a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS is an extention of HTTP</a>. An HTTPS connection starts with a TLS client/server handshake whereof the certificate is sent/validated and the TLS parameters (cipher suite and such) are set (negotiated if allowed). Otherwise, the TLS-handshake fails and the connection is terminated.</p>

<blockquote>
<p><strong>On TLS-handshake failure</strong>, the server is likely to send a &quot;handshake failure&quot; alert. Such may occur if the certificate's CA cannot be validated by the client, or <strong><em>if client and server have no mutually supported TLS-ciphers suite</em></strong>. The TLS handshake failure is not an HTTP-level response; it's part of the TLS protocol. The HTTP layer comes into play only after a secure TLS connection has been established. If the TLS handshake fails, the HTTP layer doesn't have an opportunity to send an HTTP response code because the connection hasn't been established.</p>
</blockquote>

<h2>OpenSSL</h2>

<p>The industry-standard library and its CLI utility for all things TLS.</p>

<p>The OpenSSL utility, <a href="https://www.openssl.org/"><code>openssl</code></a>, is a multi-purpose tool used to create, parse, validate, convert formats, and test TLS keys, certificates, and such.</p>

<h3>References:</h3>

<ul>
<li>Manual (<code>man</code>) pages are available for each <code>openssl &lt;command&gt;</code> at <code>man openssl-&lt;command&gt;</code>.</li>
<li>For the list of available <code>openssl</code> commands (by category), simply run: <code>openssl</code>.</li>
<li><a href="TLS.openssl.sh"><code>TLS.openssl.sh</code></a><br></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc6125">RFC 6125</a> Identity (DNS names) regarding X.509 certificates.</li>
</ul>

<h2>Glossary</h2>

<h3>Transport Layer Security (TLS)</h3>

<p>Transport Layer Security is the newer security protocol that <strong><em>replaced Secure Sockets Layer (SSL)</em></strong>. Though the SSL protocol is obsolete and has been so for about a quarter century, the term &quot;SSL&quot; stubbornly remains with us, e.g., &quot;OpenSSL&quot;. Engineers often refer to TLS as SSL, while actual SSL (protocols, ciphers, certificates and keys) are extremely insecure and entirely inadequate. Never use actual SSL.</p>

<h3><a href="https://en.wikipedia.org/wiki/X.509" title="Wikipedia">X.509</a></h3>

<p>A standard that defines the format of public key certificates. These certificates are used in various security and networking protocols, including TLS/SSL, which is the basis for secure connections on the internet. The X.509 standard is part of the X.500 series of standards defined by the ITU-T (International Telecommunication Union Telecommunication Standardization Sector) for the Directory Services.</p>

<p>The X.509 certificate standard uses <a href="https://en.wikipedia.org/wiki/ASN.1"><strong>ASN.1</strong></a> (Abstract Syntax Notation One) to define the data structure and Distinguished Encoding Rules (DER) to specify how that data is serialized into a binary format. This means ASN.1 provides the &quot;what&quot; (the data types and their relationships) and DER provides the &quot;how&quot; (the specific rules for converting those types into a consistent, unambiguous byte stream for storage and transmission).</p>

<p>Features of X.509 certificates include:</p>

<ul>
<li>Public Key: The certificate includes the public key of the certificate holder.
Identity Information: It contains identity information about the holder, such as the common name (<code>CN</code>), organization (<code>O</code>), and country (<code>C</code>). This information is used to verify the identity of the entity presenting the certificate.</li>
<li>Issuer: The certificate specifies the issuing CA that has signed and issued the certificate, thus vouching for its authenticity.</li>
<li>Serial Number: Each certificate issued by a CA is given a unique serial number to distinguish it from other certificates.</li>
<li>Validity Period: Certificates are valid for a specific period, indicated by the &quot;<code>Not Before</code>&quot; and &quot;<code>Not After</code>&quot; dates. The certificate should not be considered valid before or after this period.</li>
<li>Digital Signature: The issuing CA digitally signs the certificate to prove its authenticity. The signature can be verified using the CA's public key.</li>
</ul>

<p>X.509 certificates play a crucial role in establishing trust in digital communications. By verifying the <strong><em>chain of trust</em></strong> from a given certificate up to a trusted root CA, entities can establish secure communication channels. This trust model underpins the security of HTTPS websites, email encryption (S/MIME), and many other protocols that secure data exchange over networks.</p>

<h3>Encodings v. Formats</h3>

<ul>
<li><strong>Encoding</strong>: The method by which data is transformed into a specific format. Encoding does not necessarily imply any particular data structure. Example: Base64 encoding, which converts binary data into ASCII characters.</li>
<li><strong>Format</strong>: A structured arrangement of data, usually specified by standards that define the exact way data should be organized. In cryptography, formats often dictate how keys, certificates, and encrypted messages should be structured. Example: The PKCS#12 format, which defines a way to store a private key and a certificate, optionally with additional metadata and/or encryption.</li>
</ul>

<p>Reference:</p>

<ul>
<li><code>man openssl-format-options</code></li>
</ul>

<p><a name=der></a></p>

<h4>DER (Distinguished Encoding Rules)</h4>

<p>A <strong>binary encoding</strong> scheme; a subset of BER (<a href="https://en.wikipedia.org/wiki/X.690" title="Wikipedia.org">X.690</a>) that eliminates some of the superset's flexibility to guarantee there is one and only one way to encode a message. That is, to encode, decode, re-encode, re-decode, and re-re-encode a DER message, all those encodings remain identical.</p>

<p>DER is commonly used in security-related applications such as X.509 digital certificates (and keys). Common extensions are: <code>.crt</code>, <code>.cer</code>, and <code>.der</code> if a public certificate; <code>.key</code> if a private key, so <strong><em>do not rely on the file's extension</em></strong> to indicate format. Not many applications require DER formatted certificates or keys, but this binary form is useful for conversions between otherwise incompmatible ASCII-based encodings.</p>

<pre><code class="language-bash"># Convert format: DER to PEM (From binary to human-readable text) 
openssl x509 -inform der -in certificate.der -outform pem -out certificate.pem

# Convert format: PEM to DER (From human-readable text to binary) 
openssl x509 -in certificate.pem -outform der -out certificate.der

</code></pre>

<h4><a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail" title="Wikipedia.org">PEM</a> (Privacy Enhanced Mail)</h4>

<p><strong>Base64 encoded</strong> (<a href="https://en.wikipedia.org/wiki/ASCII" title="Wikipedia.org">ASCII</a>) file format. PEM is the most common &quot;format&quot; (encoding) for TLS certificate and key files; widely used in web servers and other network applications where textual (ASCII) configuration files are standard. Common extensions for PEM files are: <code>.crt</code>, <code>.cer</code>, and <code>.pem</code> if the document is a public certificate; <code>.key</code> if it's a (private) key. However, <strong>do not rely on the filename extension to indicate its actual format</strong>. A <code>*.pem</code> <em>may (also) contain a key</em>.</p>

<blockquote>
<p>Many cryptography standards use <a href="https://en.wikipedia.org/wiki/ASN.1">ASN.1</a> Interface Description Language (IDL) to define their data structures, and <a href="#der">DER</a> to serialize those structures. Because DER produces binary output, it can be challenging to transmit the resulting files through systems, like electronic mail, that only support ASCII. PEM solves that.</p>
</blockquote>

<p>PEM <em>certificates</em> include a header and footer:</p>

<pre><code class="language-text">-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----
</code></pre>

<p>A <em>certificate</em> file may contain many such concatenated certificates. The most common certificate files are those of either a list of root CA certificates AKA trust-store AKA ca-bundle file, or a certificate chain AKA full-chain certificate. The latter is commonly referred to as the &quot;server certificate&quot;.</p>

<p>The full-chain (of trust) certificates must be properly ordered, whereof the first cerificate is that of the end-entity (server). Each cerificate thereafter is that of the prior's Issuer; the CA that signed (and therefore validates) the preceding certificate. This chain goes all the way back to, but not (typically) including, the root-CA certificate.</p>

<p>That root-CA certificate is expected to be in the clients' trust store. The root-CA certificate is distinguished by having <em>identical</em> Subject and Issuer, AKA it is a Self-signed Certificate of a trustworthy Certificate Authority.</p>

<p>Many command-line tools, including OpenSSL's (<code>openssl</code>), read PEM files. It is especially common in Unix/Linux environments.</p>

<h4>JKS (Java KeyStore)</h4>

<p>A proprietary file format developed by Oracle for storing cryptographic keys and certificates securely.
It is primarily used in Java applications to manage and secure keys and certificates for TLS and other uses
(Document Signing, Software Integrity Checking, Internal Communications, &hellip;).</p>

<ul>
<li>Structure: JKS files contain one or more keys or certificates, and the file itself is protected by a password.
Each entry in a JKS file is also individually password-protected.</li>
<li>Format: The JKS file format is a <strong>binary</strong> format specifically designed for use within Java applications.
It is not readable as plain text and is not based on any standard encoding rules; <strong>JKS is not DER</strong> encoded.</li>
</ul>

<p>Also, take care to not mistake JKS with similar acronyms regarding the unrelated JSON-formatted PKI, such as JWKS, JWK, &hellip;.</p>

<h4><a href="https://en.wikipedia.org/wiki/PKCS" title="Wikipedia.org">PKCS</a> (Public-Key Cryptography Standards)</h4>

<p>PKCS encompasses <strong>a group of standards</strong>, including specifications for various formats and protocols designed for secure cryptographic communication; encrypted data, private keys, and public key certificates, among other things.</p>

<h5>PKCS#1</h5>

<p>Defines the format for RSA encryption and signing.
It specifies how to encode data for signing or encryption with RSA.</p>

<h5><a href="https://en.wikipedia.org/wiki/PKCS_7">PKCS#7</a>/P7B/CMS</h5>

<p>A standard (<a href="https://datatracker.ietf.org/doc/html/rfc5652" title="IETF.org">RFC-5652</a>) for encryption and signing, suitable for messages like signed or encrypted emails. It defines <strong>a general syntax</strong> for data that may have cryptography applied to it, such as digital signatures and encryption. It is widely used in various security and cryptographic applications. This standard is versatile, supporting not only encryption and digital signatures but also other enhancements like data compression and certificate dissemination.</p>

<p>This format <strong>does not contain any key</strong>.
One or more Base64 ASCII <strong>certificates</strong> are stored in a <strong><code>.p7b</code></strong> or <code>.p7c</code> file.
The format is commonly used in <strong>Windows</strong> and <strong>Java</strong> applications.</p>

<p>Windows Server's Certificate Services (<strong>AD CS</strong>) returns the <strong>fullchain certificate</strong> (per approved CSR) as <code>*.p7b</code> having that (PKCS#7) format.</p>

<pre><code class="language-bash">## Convert from P7B to PEM
openssl pkcs7 -print_certs -in input.p7b -out output.pem
</code></pre>

<h5><a href="https://en.wikipedia.org/wiki/PKCS_8">PKCS#8</a></h5>

<p>Specifies the <strong>private key</strong> information syntax, which is a format for storing private keys;
both encrypted and unencrypted forms.</p>

<h5>PKCS#10/<a href="https://en.wikipedia.org/wiki/Certificate_signing_request">CSR</a></h5>

<p>A format regarding <a href="https://en.wikipedia.org/wiki/Certificate_signing_request" title="Wikipedia.org">Certificate Signing Request</a> (<strong>CSR</strong>) data structure, for requesting certificates from a CA. It specifies what information the CSR contains and how that information is organized. This (<a href="https://en.wikipedia.org/wiki/ASN.1" title="Wikipedia.org">ASN.1</a>) format is recognized universally and is the standard format for CSRs regardless of the software or platform being used. The file may be in either DER or PEM format. Common filename extensions for a CSR are <strong><code>.csr</code></strong>, <code>.pem</code> and <code>.der</code>.</p>

<h5><a href="https://en.wikipedia.org/wiki/PKCS_12" title="Wikipedia.org">PKCS#12</a>/PFX/P12</h5>

<p>A <strong>binary archive-file format</strong> for storing many cryptographic objects (<strong>certificates and key</strong>) in a single password-protected file, each in a <em>SafeBag</em> (container); successor to Microsoft's PFX. Common filename extensions are <code>.pfx</code> and <code>.p12</code>. Often used in Java applications and across Windows machines. Code-signing certificates stored in PFX are also often used for signing with <strong>Microsoft Authenticode</strong>.</p>

<p>Characteristics and uses of PKCS#12 include:</p>

<ul>
<li>Secure Storage and Transport: PKCS#12 files provide a means for secure storage and transport of a user’s certificates and private keys across different systems or applications.
Interoperability: Due to its standardization, PKCS#12 files are supported by a wide range of software and devices, including web servers, email clients, and VPN clients, facilitating interoperability between different systems and platforms.</li>
<li>Encryption: The contents of a PKCS#12 file, including private keys, certificates, and other sensitive information, can be encrypted with a password. This encryption uses strong cryptographic algorithms to protect the contents from unauthorized access.</li>
<li>Bundling: A single PKCS#12 file can contain multiple certificates and keys, making it easier to manage and deploy a complete cryptographic identity or chain of trust. This is particularly useful for SSL/TLS certificates, where a server certificate must be installed along with its corresponding private key and any intermediate certificates.</li>
</ul>

<h5><a href="https://en.wikipedia.org/wiki/Certificate_Management_over_CMS" title="Wikipedia.org">CMC</a> (Certificate Management over CMS)</h5>

<p>A standard (<a href="https://datatracker.ietf.org/doc/html/rfc5272" title="IETF.org">RFC-5272</a>/<a href="https://datatracker.ietf.org/doc/html/rfc5273" title="IETF.org">RFC-5273</a>) for certificate management that allows for various operations, including requesting certificate issuance, renewal, and revocation.</p>

<p>A CMC-formatted CSR is essentially a more complex and versatile request format compared to the traditional PKCS#10 CSR. It is designed to support a wider range of certificate management functions and to facilitate more sophisticated interactions between entities requesting certificates (clients) and the entities issuing them (CAs).</p>

<p>CMC-formatted CSRs are particularly useful in environments requiring <strong>advanced certificate management capabilities</strong>, especially where multiple certificate-related operations need to be performed in a streamlined and secure manner. Due to its complexity and advanced features, CMC is <strong>often used in enterprise environments</strong>, in systems with large-scale certificate management needs, or in scenarios requiring <strong>automated certificate lifecycle management</strong>.</p>

<p><a href="https://access.redhat.com/documentation/en-us/red_hat_certificate_system/9/html/administration_guide/issuing_certificates_using_cmc" title="redhat.com">CMC @ RHEL</a></p>

<h3>Key</h3>

<p>AKA Private Key; the private artifact of an asymmetric (public-private) key pair creation. The server's key is private; a secret that must be well protected, never shared, and sufficiently rotated. The public artifact is the server's certificate.</p>

<h3><a href="https://en.wikipedia.org/wiki/Public_key_certificate" title="Wikipedia.org">Certificate</a></h3>

<p>AKA Public Key Certificate, which is composed of the public artifact (AKA Public Key) of an asymmetric (public-private) key pair creation, plus metadata extracted from the CSR. The certificate is public; presented by a web server whenever a new TLS connection is requested. The certificate contains its Subject host name (FQDN), which must match the FQDN of server sending it, and the Issuer.</p>

<p>The certificate's Issuer is the CA that signed it. Every CA has a certificate, which is used to verify the server's CA-signed certificate.  If the Issuer is not a Root CA, then it must be an Intermediate CA, and so the chain of trust may continue until the Root-CA certificate is obtained and used to verify the signature of the preceding Intermediate-CA certificate in the chain of certificates sent to the client. All such cert bundled into one file and typically referred to simply as the &quot;server certificate&quot;.</p>

<h4>SAN (Subject Alternative Name)</h4>

<p>Extension for <strong>CN</strong> (Common Name) AKA Domain Name; a field of a certificate that indicates for which domain(s) the certificate is valid. A single certificate may contain many SANs. That is, may be valid for many different domain names.</p>

<h4>Wildcard Certificate</h4>

<p>The asterisk character (<code>*</code>) is the wildcard, and can be substituted with any valid hostname. Instead of being issued for a specific Fully Qualified Domain Name (FQDN), such as <code>app.example.com</code>, wildcard certs are valid for a whole range of subdomain names. So a cert issued to <code>*.example.com</code> would cover <code>app.example.com</code> and <code>cdn.example.com</code>, yet <em>not</em> <code>other.cdn.example.com</code>.</p>

<h3><a href="https://en.wikipedia.org/wiki/Certificate_authority" title="Wikipedia.org">Certificate Authority</a> (CA)</h3>

<p>A certificate authority verifies details about a domain owner’s request for certificates. Only after validating the certificate-signing request (CSR) do CAs sign and issue the server certificate; typically returning the full-chain (of trust) certificate. Browsers and operating systems maintain a list of trusted certificate authorities. If a server certificate is signed by one of these trusted CAs, it will also be trusted. There are several organizations and forums that maintain lists of trustworthy CAs; it is fragmented.</p>

<h4><a href="https://en.wikipedia.org/wiki/X.509#Certificate_chains_and_cross-certification">Full-Chain Certificate</a></h4>

<p>AKA &quot;server certificate&quot; AKA &quot;certificate chain&quot; file.</p>

<p>A &quot;full chain&quot; certificate refers to a certificate file containing the entire <strong><em>chain of trust</em></strong>; the end-entity (server) certificate and all the intermediate certificate(s) up to, but not icluding, the root CA certificate. This chain of certificates helps establish trust from the end-entity certificate back to a trusted root certificate authority (CA). Most CAs default to this &quot;bundle&quot; or &quot;full chain&quot; option when delivering certificates.</p>

<p>Order matters. The first certificate listed is that of the end-entity (server). The second certificate (intermidiary) is that of the CA that signed (and therefore can verify) the 1st, the 3rd verifies the 2nd, and so on. So, the last (Nth) intermidate certificate would be validated by the root CA, which must reside in clients' (TLS) trust store.</p>

<blockquote>
<p><strong>Certificate Chain Trust</strong>: The server is responsible for sending its own certificate and any intermediate certificates necessary to form a complete path to a root certificate trusted by clients. The inclusion of intermediate certificates is <strong><em>crucial because clients might not have them</em></strong>, <em>unlike root certificates, which are expected to be pre-installed in clients' trust store</em>.</p>
</blockquote>

<pre><code class="language-bash"># Get the (full-chain) certificate of a server ($h) at its port ($p)
h='google.com' # Host
p='443'        # Port
openssl s_client -connect $h:$p -showcerts &lt; /dev/null &gt; ${h}_${p}.full-chain.crt

# Verify the server's ca-signed certificate ($any.crt) against the CA ($ca.crt) that signed it
# (The CA file may be a trust-store bundle; a concatenated list of CA certs in PEM format.)
openssl verify -CAfile $ca.crt $any.crt
</code></pre>

<h3>Certificate hierarchy:</h3>

<ul>
<li><p><strong>End-entity certificate</strong>: This is the certificate that corresponds to the specific domain for which the certificate is issued. It contains the public key for the server and is signed by an intermediate CA.</p></li>

<li><p><strong>Intermediate certificate(s)</strong>: Intermediate certificates sit between the end-entity certificate and the root certificate in the certificate chain. They are used to enhance security by creating a hierarchy of trust. The intermediate certificate is signed by a root CA and, in turn, signs the end-entity certificate.</p></li>
</ul>

<p>Intermediate Certificate (example)</p>

<p><code>CN: GTS CA 1C3</code></p>

<pre><code class="language-text">...                                         
 1 s:C = US, O = Google Trust Services LLC, CN = GTS CA 1C3          
   i:C = US, O = Google Trust Services LLC, CN = GTS Root R1         
   a:PKEY: rsaEncryption, 2048 (bit); sigalg: RSA-SHA256             
   v:NotBefore: Aug 13 00:00:42 2020 GMT; NotAfter: Sep 30 00:00:42 2
-----BEGIN CERTIFICATE-----                                          
MIIFljCCA36gAwIBAgINAgO8U1lrNMcY9QFQZjANBgkqhkiG9w0BAQsFADBHMQsw     
...     
1IXNDw9bg1kWRxYtnCQ6yICmJhSFm/Y3m6xv+cXDBlHz4n/FsRC6UfTd             
-----END CERTIFICATE-----                                            
</code></pre>

<ul>
<li><p>Note that Subject (<code>s:</code>) and Issuer (<code>i:</code>) differ.</p>

<ul>
<li><code>s:..., CN = GTS CA 1C3</code></li>
<li><code>i:..., CN = GTS Root R1</code>

<ul>
<li>Root cerficate is &quot;<code>GTS Root R1</code>&quot;,
and it is not included in this full-chain certificate.</li>
</ul></li>
</ul></li>

<li><p><strong>Root certificate</strong>: The root certificate is the top-level certificate in the hierarchy and is self-signed. (Subject, &quot;<code>s:</code>&quot; and Issuer &quot;<code>i:</code>&quot; are the same entity.)  It is the ultimate authority that establishes trust in the entire chain. Web browsers and other client applications come pre-installed with a set of trusted root certificates.</p></li>
</ul>

<p>When a client, such as a web browser, connects to a server secured with SSL/TLS, it checks the certificate chain to ensure that the end-entity (server) certificate is valid and signed by a trusted intermediate certificate, which, in turn, is signed by a trusted root certificate. That is, the client must have its own set of trusted-CA certificates, or use that of the system (OS) in which it is running, against which to validate the server's certificate.</p>

<p>Including the full chain when configuring SSL/TLS on a server is important to ensure that clients can validate the server's certificate properly. Without the full chain, clients may not be able to establish the chain of trust, and the connection could be deemed untrusted.</p>

<h3><a href="https://en.wikipedia.org/wiki/Certificate_revocation_list" title="Wikipedia.org">CRL</a> (Certificate Revocation List)</h3>

<p>Certificates may include information on how to access a certificate revocation list.
Clients will download and check this list to make sure the certificate has not been revoked.
The CRL is a list or database of TLS certificates (serial numbers) that have been revoked by the issuing CA before their scheduled expiration date and should no longer be trusted.</p>

<p>The CRL method is <strong>plagued by several key limitations</strong>
that make it less effective for modern, large-scale internet use:</p>

<ul>
<li><strong>Latency and performance issues</strong>: The CRL file could be very large, especially for major CAs that issued millions of certificates. The need to download and parse this potentially massive file every time a client needed to check a certificate caused significant delays during the TLS handshake.</li>
<li><strong>Stale information</strong>: CAs only published new CRLs at regular, predefined intervals (e.g., every 24 hours). This created a &quot;window of vulnerability&quot; where a certificate could be revoked but remain usable until the next CRL was published and downloaded by clients.</li>
<li><strong>Scalability problems</strong>: The original CRL architecture did not scale well with the explosive growth of the internet. The network traffic and server load involved with millions of clients downloading large CRL files became a major strain on the CA infrastructure.</li>
<li><strong>&quot;Soft-fail&quot; behavior</strong>: Many browsers were configured to &quot;soft-fail&quot; the CRL check if they couldn't reach the CDP to download the list. Rather than halting the connection, they would proceed anyway, leaving users vulnerable if a malicious actor blocked the CRL download.</li>
</ul>

<p><strong>CRLs are slowly being depricated</strong> as alternate certificate revocation technologies (such as OCSP responders) are increasingly used instead. <strong>Nevertheless, CRLs are still widely used</strong> by CAs.</p>

<h3><a href="https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol" title="Wikipedia.org">OCSP</a> (Online Certificate Status Protocol)</h3>

<p>OCSP is an internet protocol (<a href="https://datatracker.ietf.org/doc/html/rfc6960" title="IETF.org">RFC-6960</a>) allowing applications to check the revocation status of a certificate in real-time without needing to download and parse a CRL.</p>

<p>The OCSP protocol is a TLS extension; <strong>a replacement for CRLs</strong>, with the benefits of being more real-time and requiring less bandwidth. However, OCSP also introduces its own complexities, such as the need for additional infrastructure to handle real-time requests.</p>

<p>Clients query the OCSP responder to check if a certificate has been revoked. Like end-entity (server) certificates, the OSCP response is also cryptographically signed and has its own chain of trust, so clients may verify it regardless of how it arrives. This allows for <strong>OSCP Stapling</strong>.</p>

<h4><a href="https://en.wikipedia.org/wiki/OCSP_stapling" title="Wikipedia.org">OSCP Stapling</a></h4>

<p>Formally known as the <em>TLS Certificate Status Request</em> extension (<a href="https://datatracker.ietf.org/doc/html/rfc6066#section-8" title="IETF.org">RFC&#x2011;6066</a>), OSCP Stapling is <strong>a standard for checking the revocation status of X.509 digital certificates</strong>.</p>

<p>This is how it works:</p>

<p>The server routinely queries the OCSP responder, and then &quot;staples&quot; the response to its TLS-handshake response per client connection. So, the server bears the resource cost involved in providing revocation status. This method reduces the performance impact, alleviates privacy concerns, and ensures that clients receive up-to-date revocation information without requiring separate OCSP queries.</p>

<h3>Domain Validation (DV)</h3>

<p>A domain validated certificate will be issued to somebody who has proven they control the domain name requested for the certificate. This proof often takes the form of serving a unique token from your web server or DNS records, which the CA will check for before issuing the certificate.</p>

<h3>Organization Validation (OV)</h3>

<p>An organization validated certificate means that the certificate authority also verified the company name and address in public databases. This information is put into the certificate, and is typically displayed only when the user clicks the green padlock icon to investigate further.</p>

<h3>Extended Validation (EV)</h3>

<p>Extended validation is <strong><em>more thorough than domain or organization validation</em></strong>. EV certificates are issued after checking not only domain ownership, but also verifying the existence and location of the legal entity requesting the certificate, and that said entity controls the domain being verified.</p>

<p>Unlike DV and OV certificates, EV cannot be issued as a wildcard certificate.</p>

<p>EV certificate also <strong><em>gets special treatment in web browsers</em></strong>. Whereas browsers typically denote a DV certificate with a <strong><em>green-padlock icon</em></strong>, EV certificates also show a larger green bar containing the name of the organization it was issued to. This is intended to reduce phishing attacks, though some studies show that users tend not to notice when this green bar is missing.</p>

<h2>Intermediate CA</h2>

<p>When creating an Intermediate Certificate Authority (CA) to scope its authority to a specific subset of CIDRs, IPs,
hostnames, or other identifiers, you need to carefully configure the certificate's extensions and constraints.
Here are the key parameters and considerations:</p>

<p>How to configure an Intermediate CA using OpenSSL:</p>

<ol>
<li><p><strong>OpenSSL Configuration File</strong> (<code>openssl.cnf</code>):</p>

<pre><code class="language-ini">[ v3_intermediate_ca ]
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer
basicConstraints = critical, CA:TRUE, pathlen:0
keyUsage = critical, digitalSignature, cRLSign, keyCertSign
nameConstraints = critical, permitted;DNS:example.com, permitted;IP:192.168.1.0/24
</code></pre></li>
</ol>

<ul>
<li>Set <strong>Basic Constraints</strong> to define CA capabilities and path length.

<ul>
<li>Indicate that the certificate is for a CA (<code>CA: TRUE</code>).</li>
<li>Specify the maximum depth of subordinate CAs allowed (<code>pathlen</code>):

<ul>
<li><code>pathlen:0</code> means the Intermediate CA can only issue end-entity certificates (no further subordinate CAs).</li>
<li><code>pathlen:1</code> allows one level of subordinate CAs.</li>
</ul></li>
</ul></li>
<li>Configure <strong>Key Usage</strong> appropriately.

<ul>
<li>Ensure the <code>keyCertSign</code> and <code>cRLSign</code> bits are set for CA certificates.</li>
<li><strong>Extended Key Usage</strong> (optional):

<ul>
<li>Limit the purposes for which the Intermediate CA can issue certificates (e.g., server authentication, client authentication).</li>
</ul></li>
</ul></li>

<li><p>Use the <strong>Name Constraints</strong> extension to limit DNS names, IP ranges, etc.</p>

<ul>
<li>This is <strong>the primary mechanism</strong> to limit the scope of an Intermediate CA's authority.</li>
<li>It can restrict the CA to issuing certificates for specific:

<ul>
<li><strong>DNS names</strong> (e.g., <code>example.com</code>, <code>*.example.com</code>)</li>
<li><strong>IP addresses</strong> (e.g., <code>192.168.1.0/24</code>, <code>10.0.0.0/8</code>)</li>
<li><strong>Email addresses</strong> (e.g., <code>@example.com</code>)</li>
<li><strong>Directory names</strong> (e.g., distinguished names in LDAP)</li>
</ul></li>
<li><strong>Syntax</strong>:

<ul>
<li><code>permittedSubtrees</code>: Specifies allowed names or IP ranges.</li>
<li><code>excludedSubtrees</code>: Specifies explicitly excluded names or IP ranges.</li>
</ul></li>

<li><p>Example:</p>

<ul>
<li><p>To allow only <code>*.example.com</code> and <code>192.168.1.0/24</code>:</p>

<pre><code class="language-plaintext">permittedSubtrees:
- DNS: example.com
- IP: 192.168.1.0/24
</code></pre></li>

<li><p>To exclude <code>*.internal.example.com</code>:</p>

<pre><code class="language-plaintext">excludedSubtrees:
- DNS: internal.example.com
</code></pre></li>
</ul></li>
</ul></li>

<li><p>Optionally, define <strong>Certificate Policies</strong> and ensure proper revocation mechanisms.</p></li>
</ul>

<ol>
<li><p><strong>Generate the Intermediate CA Certificate</strong>:</p>

<pre><code class="language-bash">openssl req -new -key intermediate.key -out intermediate.csr
openssl x509 -req -in intermediate.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out intermediate.crt -days 365 -extfile openssl.cnf -extensions v3_intermediate_ca
</code></pre></li>
</ol>

<h2>Projects</h2>

<h3>@ <a href="https://docs.docker.com/engine/swarm/configs/" title="docs.docker.com/swarm/configs">Docker/Nginx</a></h3>

<ul>
<li>Create: <a href="TLS.openssl.sh"><code>TLS.openssl.sh</code></a></li>
<li>Deploy: <a href="stack-nginx.yml"><code>stack-nginx.yml</code></a></li>
</ul>

<h3><a href="https://github.com/FiloSottile/mkcert"><code>mkcert</code></a> (HTTPS @ <code>localhost</code>)</h3>

<p>A simple tool for making locally-trusted development certificates.
It requires no configuration.
Worthless @ Windows 10.</p>

<h4>@ Windows/WSL (Golang/cURL)</h4>

<p> <a href="https://zeropointdevelopment.com/how-to-get-https-working-in-windows-10-localhost-dev-environment/">Add a self-signed CA (<code>root-ca.crt</code>) to Windows 10</a>.</p>

<h5>FAIL:</h5>

<ul>
<li><code>x509 Certificate Signed by Unknown Authority</code> (Golang)</li>
<li><code>(60) SSL certificate : unable to get local issuer certificate</code> (cURL)</li>
</ul>

<h5>FIX:</h5>

<ol>
<li>Generate both a CA root certificate and the server's certificate using <code>openssl</code>

<ul>
<li>Use <code>Makefile</code> recipes @ <code>uqrate/v1/assets/keys/tls/openssl/</code></li>
</ul></li>
<li>Per OS:

<ul>
<li>@ Linux

<ul>
<li><p>Either append the content of the CA's root certificate file (<code>root-ca.crt</code>) to <code>ca-certificates.crt</code> file of the <code>/etc/ssl/certs/</code> directory, or copy the file itself to that directory.</p>

<pre><code class="language-bash">sudo vim /etc/ssl/certs/ca-certificates.crt
</code></pre>

<ul>
<li>@ XPC, <code>root-ca-swarm.foo.crt</code> is a standalone file under <code>/etc/ssl/certs</code>.</li>
<li>@ HTPC, the content of that certificate is appended to <code>ca-certificates.crt</code> file.</li>
</ul></li>
</ul></li>
<li>@ Windows

<ul>
<li><code>Certificates.msc</code> : Local Machine or Current User

<ul>
<li>Note that <code>WSL</code> apps don't use Windows certs store <del>@ HTPC configuration, Adding CA (openssl) @ Current User failed to fix either Golang or cURL failure. Then, added to Local Machine, but that failed to fix issue @ cURL (Golang untested). Then appended to WSL's  certs file (above method), and that fixed at both cURL and Golang. BTW, &quot;Golang&quot; means <code>go run ...</code>; was reporting <code>x509 Certificate Signed by Unknown Authority</code>.</del></li>
<li>Open per <code>Win+R</code> &gt; MMC &gt; File &gt; Add/Remove Snap-in &gt; Certificates &gt; Trusted Root Certification Authorities &gt; All Tasks &gt; Import

<ul>
<li>Import: <code>root-ca.crt</code></li>
</ul></li>

<li><p>@ PowerShell; <strong><em>alt method</em></strong>; effectiveness is unknown.</p>

<pre><code class="language-powershell">Import-Certificate -FilePath &quot;root-ca.crt&quot; -CertStoreLocation Cert:\LocalMachine\Root
</code></pre></li>
</ul></li>
<li>@ Firefox, mod required to enable the newly added root certificate

<ul>
<li><a href="https://support.mozilla.org/en-US/kb/setting-certificate-authorities-firefox">Add CA @ Firefox</a>

<ul>
<li><code>about:config</code>

<ul>
<li><code>security.enterprise_roots.enabled</code> : <code>true</code></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ol>

<h3><a href="https://github.com/acmesh-official/acme.sh"><code>acme.sh</code></a></h3>

<h4>TL;DR</h4>

<ul>
<li>Get cert via automated DNS-01 challenge</li>
<li>List of CAs that <code>acme.sh</code> handles : <a href="https://github.com/acmesh-official/acme.sh/wiki/Server">URL and &quot;Short Name&quot;</a></li>
</ul>

<h4>HowTo</h4>

<pre><code class="language-bash">domain='target.tld'
len='4096'    # @ RSA
len='ec-384'  # @ Elliptic Curve
AWS_ACCESS_KEY_ID=&quot;AKI...&quot;
AWS_SECRET_ACCESS_KEY=&quot;58X...mdS&quot;

acme.sh --issue --server letsencrypt --dns dns_aws --ocsp-must-staple --keylength $len -d &quot;$domain&quot; -d &quot;*.$domain&quot;
</code></pre>

<ul>
<li>See <code>~/.acme.sh/account.conf</code>

<ul>
<li>Stores AWS creds that it reads from environment.</li>
</ul></li>
<li><a href="https://en.wikipedia.org/wiki/OCSP_stapling">OCSP Stapling</a> is <a href="https://blog.hboeck.de/archives/886-The-Problem-with-OCSP-Stapling-and-Must-Staple-and-why-Certificate-Revocation-is-still-broken.html">broken</a> (@ Nginx and Apache)</li>

<li><p><code>HTTP-01</code> challenge type : <a href="https://github.com/acmesh-official/acme.sh/wiki/Stateless-Mode">Stateless Mode : <code>--stateless</code></a>; requires a running, challenge-configured server.</p>

<pre><code class="language-bash"># 1. Get account thumbprint 
# Servers (per CA): https://github.com/acmesh-official/acme.sh/wiki/Server
acme.sh --register-account --config-home  /acme.sh/ca \
    --server https://acme-staging-v02.api.letsencrypt.org/directory

[Tue Jul 27 21:24:11 UTC 2021] Create account key ok.
...
[Tue Jul 27 21:24:12 UTC 2021] ACCOUNT_THUMBPRINT='Wcb...xfY'

# 2. Configure (Nginx) web server endpoint: &lt;DOMAIN&gt;/.well-known/acme-challenge/&lt;TOKEN&gt; 
#    that responds with string: &lt;TOKEN&gt;.&lt;ACCT_THUMBPRINT&gt; 
server {
    ...
    location ~ ^/\.well-known/acme-challenge/([-_a-zA-Z0-9]+)$ {
        default_type text/plain;
        return 200 &quot;$1.Wcb...xfY&quot;;
    }
    ...
}

# 3. Get cert by stateless (HTTP-01) challenge:
acme.sh --issue -d ... --stateless
</code></pre>

<ul>
<li>AWS-credentialed bot-user (@ <code>acme.sh</code>) must have AWS role/policy
required to perform the DNS-01 challenge</li>
</ul></li>

<li><p><a href="https://github.com/acmesh-official/acme.sh/wiki/Run-acme.sh-in-docker">@ Docker</a></p></li>

<li><p><a href="https://www.cyberciti.biz/faq/how-to-install-letsencrypt-free-ssltls-for-nginx-certificate-on-alpine-linux/" title="cyberciti.biz 2020">@ Nginx : Alpine Linux</a> | <a href="https://www.cyberciti.biz/faq/route-53-lets-encrypt-wildcard-certificate-with-acme-sh/">Using <code>acme.sh</code></a> |</p>

<ul>
<li><a href="https://wiki.alpinelinux.org/wiki/Nginx_as_reverse_proxy_with_acme_(letsencrypt)" title="wiki.alpinelinux.org @ 2017">Setup Nginx as reverse proxy with TLS, per <code>acme.sh</code> (@ <code>letsencrypt</code>)</a></li>
</ul></li>
</ul>

<h3><a href="https://certbot.eff.org/docs" title="certbot.eff.org">Certbot</a> | <a href="https://certbot.eff.org/docs/install.html#running-with-docker">certbot @ Docker</a> | <a href="https://certbot-dns-route53.readthedocs.io/en/stable/"><code>certbot-dns-route53</code></a> | <a href="https://hub.docker.com/u/certbot" title="@ Docker Hub">+DNS Provider plugin</a></h3>

<p>Certbot is the client advised by <code>letsencrypt.org</code>; we used <code>acme.sh</code> instead only because its Docker image was better advertised. Certbot @ docker should perform as well. Both automate the cert request and the DNS-01 challenge per suitable DNS providers (both handle AWS/Route53)</p>

<blockquote>
<p>The dns_route53 plugin automates the process of completing a <code>dns-01</code> challenge (<code>DNS01</code>) by creating, and subsequently removing, <code>TXT</code> records using the Amazon Web Services Route 53 API.</p>
</blockquote>

<ul>
<li>Gets certs from <code>letsencrypt.org</code>

<ul>
<li><code>privkey.pem</code> : SECRET; Private key for the certificate.</li>
<li><code>fullchain.pem</code> : All certificates, including server certificate (aka leaf certificate or end-entity certificate). The server certificate is the <em>first one</em> in this file, followed by any intermediates.</li>
<li><code>cert.pem</code> : server certificate

<ul>
<li><code>chain.pem</code> (if intermediate certs)</li>
</ul></li>
</ul></li>
<li><a href="https://certbot.eff.org/docs/using.html#where-certs">Location of certificates</a>

<ul>
<li><code>/etc/letsencrypt/live/$domain</code> : symlinks to current versions</li>
<li><code>/etc/letsencrypt/archive</code> : previous versions</li>
<li><code>/etc/letsencrypt/keys</code> : previous versions</li>
</ul></li>
<li><code>dns_route53</code> plugin | Docker image : <a href="https://hub.docker.com/r/certbot/dns-route53"><code>certbot/dns-route53</code></a>

<ul>
<li>Automates the process of completing a <code>dns-01</code> challenge by creating, and subsequently removing, <code>TXT</code> records using the Amazon Web Services Route 53 API.</li>
</ul></li>

<li><p><a href="https://certbot.eff.org/docs/using.html#pre-and-post-validation-hooks">Hooks</a> (Pre and Post) @ manual mode (<code>--manual</code>)</p>

<pre><code class="language-bash">certbot certonly --manual \
    --manual-auth-hook /path/to/http/authenticator.sh \
    --manual-cleanup-hook /path/to/http/cleanup.sh -d secure.example.com
</code></pre></li>
</ul>

<h3><a href="https://github.com/go-acme/lego" title="GitHub 4.7K stars"><code>go-acme/lego</code></a> | <a href="https://go-acme.github.io/lego">Docs</a></h3>

<blockquote>
<p>Let's Encrypt client and ACME library written in Go.</p>
</blockquote>

<p>Integrations w/ DNS providers; <a href="https://go-acme.github.io/lego/dns/route53/">AWS Route53</a></p>

<h3><a href="https://github.com/caddyserver/certmagic" title="GitHub 3.7K stars">CertMagic (Caddy)</a></h3>

<blockquote>
<p>mature, robust, and capable ACME client integration for Go</p>
</blockquote>

<pre><code class="language-golang">// @ HTTP
http.ListenAndServe(&quot;:80&quot;, mux)

//... replace that with this ...

// @ CertMagic : HTTPS with HTTP-&gt;HTTPS redirects 
certmagic.HTTPS([]string{&quot;example.com&quot;}, mux)
</code></pre>

<h2><a href="https://www.digitalocean.com/community/tutorials/a-comparison-of-let-s-encrypt-commercial-and-private-certificate-authorities-and-self-signed-ssl-certificates" title="digitalocean.com 2017">Compare SSL Certificates</a></h2>

<ul>
<li><a href="https://letsencrypt.org/getting-started/" title="letsencrypt.org">Let's Encrypt</a>

<ul>
<li>Free, DV only, 90 days, ACME protocol</li>
</ul></li>
<li>Commercial/Private CAs

<ul>
<li>DV, OV, and EV, 1-3 years, $10-$1000

<ul>
<li>@ EV, browser shows <strong><em>green padlock icon</em></strong></li>
</ul></li>
</ul></li>
<li>Self-Signed

<ul>
<li>DV, OV, untrusted by browsers</li>
</ul></li>
</ul>

<h3>EV Certificates</h3>

<ul>
<li><a href="https://www.digicert.com/tls-ssl/compare-certificates">digicert.com</a> (powers GeoTrust, Thawte)

<ul>
<li>$344/yr</li>
<li>&quot;Supports 2048-bit public key encryption (3072-bit and 4096-bit available)&quot;</li>
<li>&quot;ECC public-key cryptography (supports hash functions: 256 and 384)&quot;</li>
</ul></li>
<li><a href="https://ssl.comodo.com/ssl-ev-certificates-extended-validation"><code>ssl.comodo.com</code></a>

<ul>
<li>@ $250/yr</li>
<li>&quot;Strongest SHA2 &amp; ECC Encryption&quot;</li>
</ul></li>
<li><a href="https://www.godaddy.com/web-security/ssl-certificate">www.godaddy.com</a>

<ul>
<li>$125/yr - 1 domain</li>
<li>$320/yr - Multiple Websites (UCC/SAN)</li>
<li>&quot;Strong SHA-2 and 2048-bit encryption.&quot;</li>
</ul></li>
<li><a href="https://www.ssl.com/certificates/ev/">www.ssl.com</a>

<ul>
<li>@ $250/yr</li>
<li>&quot;2048/4096 SHA2 RSA (ECDSA supported)&quot;</li>
</ul></li>
</ul>

<h3><a href="https://letsencrypt.org/getting-started/" title="letsencrypt.org">Let's Encrypt</a> : ACME protocol : <a href="https://letsencrypt.org/docs/client-options/#clients-go">Client implementations (Golang)</a></h3>

<p>The &quot;Let’s Encrypt&quot; organization is a CA. In order to get a certificate for your website’s domain from them, you have to demonstrate control over the domain. This is accomplished using the <a href="https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment">ACME protocol</a>.</p>

<h3><a href="https://zerossl.com/pricing/">ZeroSSL Pricing</a></h3>

<p><strong>No EV</strong> (Extended Validation) <strong>certificates</strong>.</p>

<p>Domain Validation (DV) certificates ONLY.</p>

<p>@ Free &hellip;</p>

<pre><code class="language-plaintext">    90-Day Certificates - 3
    90-Day ACME Certs   - unlimited
</code></pre>

<p>@ $100/yr &hellip;</p>

<pre><code class="language-plaintext">    90-Day Certificates - unlimited
    1-Year Certificates - 3
    Multi-Domain Certs
    REST API Access
    90-Day ACME Certs   - unlimited
</code></pre>

<h3>&nbsp;</h3>
 
    </main>

    <script src="https://sempernow.github.io/refpages/sa/js/base.js"></script>
    <script>
        ;(function(o, undefined){
            'use strict'
            window.addEventListener('load', () => {
                ;(() => {})//()
                ;(() => {})//()
                ;(() => { // FOO LAB
                    const log = o.log('foo')
                        ,main = o.css('MAIN')
                    log('foo')
                    o.toDOM(main, '<h1>TEST</h1>')
                })//()
            })
        })( (typeof window !== 'undefined') 
            && (window[__APP__] = window[__APP__] || {})
                || (typeof global !== 'undefined') 
                    && (global[__APP__] = global[__APP__] || {})
        );
    </script>
</body>
</html>
